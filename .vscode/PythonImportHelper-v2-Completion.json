[
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "asarray",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "pdb,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pdb.",
        "description": "pdb.",
        "detail": "pdb.",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "numba",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numba",
        "description": "numba",
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "scipy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy",
        "description": "scipy",
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "fft",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "scipy.fftpack",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.fftpack",
        "description": "scipy.fftpack",
        "detail": "scipy.fftpack",
        "documentation": {}
    },
    {
        "label": "csimGPR.kirchhoffmigration.mod_cyMigrate",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csimGPR.kirchhoffmigration.mod_cyMigrate",
        "description": "csimGPR.kirchhoffmigration.mod_cyMigrate",
        "detail": "csimGPR.kirchhoffmigration.mod_cyMigrate",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.extension",
        "description": "distutils.extension",
        "isExtraImport": true,
        "detail": "distutils.extension",
        "documentation": {}
    },
    {
        "label": "build_ext",
        "importPath": "Cython.Distutils",
        "description": "Cython.Distutils",
        "isExtraImport": true,
        "detail": "Cython.Distutils",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "gprpy.gprpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gprpy.gprpy",
        "description": "gprpy.gprpy",
        "detail": "gprpy.gprpy",
        "documentation": {}
    },
    {
        "label": "matplotlib.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.path",
        "description": "matplotlib.path",
        "detail": "matplotlib.path",
        "documentation": {}
    },
    {
        "label": "matplotlib.patches",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "matplotlib.lines",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.lines",
        "description": "matplotlib.lines",
        "detail": "matplotlib.lines",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "matplotlib.image",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.image",
        "description": "matplotlib.image",
        "detail": "matplotlib.image",
        "documentation": {}
    },
    {
        "label": "matplotlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib",
        "description": "matplotlib",
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "cm",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "skimage.transform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "skimage.transform",
        "description": "skimage.transform",
        "detail": "skimage.transform",
        "documentation": {}
    },
    {
        "label": "csimGPR.csimGPR",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csimGPR.csimGPR",
        "description": "csimGPR.csimGPR",
        "detail": "csimGPR.csimGPR",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "scipy.signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.signal",
        "description": "scipy.signal",
        "detail": "scipy.signal",
        "documentation": {}
    },
    {
        "label": "sosfiltfilt",
        "importPath": "scipy.signal",
        "description": "scipy.signal",
        "isExtraImport": true,
        "detail": "scipy.signal",
        "documentation": {}
    },
    {
        "label": "butter",
        "importPath": "scipy.signal",
        "description": "scipy.signal",
        "isExtraImport": true,
        "detail": "scipy.signal",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "numpy.matlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy.matlib",
        "description": "numpy.matlib",
        "detail": "numpy.matlib",
        "documentation": {}
    },
    {
        "label": "scipy.interpolate",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "interp1d",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "griddata",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "scipy.io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.io",
        "description": "scipy.io",
        "detail": "scipy.io",
        "documentation": {}
    },
    {
        "label": "gridToVTK",
        "importPath": "pyevtk.hl",
        "description": "pyevtk.hl",
        "isExtraImport": true,
        "detail": "pyevtk.hl",
        "documentation": {}
    },
    {
        "label": "gridToVTK",
        "importPath": "pyevtk.hl",
        "description": "pyevtk.hl",
        "isExtraImport": true,
        "detail": "pyevtk.hl",
        "documentation": {}
    },
    {
        "label": "gridToVTK",
        "importPath": "pyevtk.hl",
        "description": "pyevtk.hl",
        "isExtraImport": true,
        "detail": "pyevtk.hl",
        "documentation": {}
    },
    {
        "label": "gprIO_2A",
        "importPath": "csimGPR.toolbox",
        "description": "csimGPR.toolbox",
        "isExtraImport": true,
        "detail": "csimGPR.toolbox",
        "documentation": {}
    },
    {
        "label": "gprIO_2B",
        "importPath": "csimGPR.toolbox",
        "description": "csimGPR.toolbox",
        "isExtraImport": true,
        "detail": "csimGPR.toolbox",
        "documentation": {}
    },
    {
        "label": "gprIO_DT1",
        "importPath": "csimGPR.toolbox",
        "description": "csimGPR.toolbox",
        "isExtraImport": true,
        "detail": "csimGPR.toolbox",
        "documentation": {}
    },
    {
        "label": "gprIO_DZT",
        "importPath": "csimGPR.toolbox",
        "description": "csimGPR.toolbox",
        "isExtraImport": true,
        "detail": "csimGPR.toolbox",
        "documentation": {}
    },
    {
        "label": "gprIO_BSQ",
        "importPath": "csimGPR.toolbox",
        "description": "csimGPR.toolbox",
        "isExtraImport": true,
        "detail": "csimGPR.toolbox",
        "documentation": {}
    },
    {
        "label": "gprIO_MALA",
        "importPath": "csimGPR.toolbox",
        "description": "csimGPR.toolbox",
        "isExtraImport": true,
        "detail": "csimGPR.toolbox",
        "documentation": {}
    },
    {
        "label": "gprpyTools",
        "importPath": "csimGPR.toolbox",
        "description": "csimGPR.toolbox",
        "isExtraImport": true,
        "detail": "csimGPR.toolbox",
        "documentation": {}
    },
    {
        "label": "Robust_NMF",
        "importPath": "csimGPR.toolbox",
        "description": "csimGPR.toolbox",
        "isExtraImport": true,
        "detail": "csimGPR.toolbox",
        "documentation": {}
    },
    {
        "label": "my_stran",
        "importPath": "csimGPR.toolbox",
        "description": "csimGPR.toolbox",
        "isExtraImport": true,
        "detail": "csimGPR.toolbox",
        "documentation": {}
    },
    {
        "label": "filters",
        "importPath": "csimGPR.toolbox",
        "description": "csimGPR.toolbox",
        "isExtraImport": true,
        "detail": "csimGPR.toolbox",
        "documentation": {}
    },
    {
        "label": "csimStartGUI",
        "importPath": "csimGPR.toolbox",
        "description": "csimGPR.toolbox",
        "isExtraImport": true,
        "detail": "csimGPR.toolbox",
        "documentation": {}
    },
    {
        "label": "mig_kirchoff",
        "importPath": "csimGPR.irlib.external",
        "description": "csimGPR.irlib.external",
        "isExtraImport": true,
        "detail": "csimGPR.irlib.external",
        "documentation": {}
    },
    {
        "label": "mig_fk",
        "importPath": "csimGPR.irlib.external",
        "description": "csimGPR.irlib.external",
        "isExtraImport": true,
        "detail": "csimGPR.irlib.external",
        "documentation": {}
    },
    {
        "label": "Pmw",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "Pmw",
        "description": "Pmw",
        "detail": "Pmw",
        "documentation": {}
    },
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "filedialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "simpledialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "FigureCanvasTkAgg",
        "importPath": "matplotlib.backends.backend_tkagg",
        "description": "matplotlib.backends.backend_tkagg",
        "isExtraImport": true,
        "detail": "matplotlib.backends.backend_tkagg",
        "documentation": {}
    },
    {
        "label": "Figure",
        "importPath": "matplotlib.figure",
        "description": "matplotlib.figure",
        "isExtraImport": true,
        "detail": "matplotlib.figure",
        "documentation": {}
    },
    {
        "label": "csimGPR",
        "importPath": "csimGPR",
        "description": "csimGPR",
        "isExtraImport": true,
        "detail": "csimGPR",
        "documentation": {}
    },
    {
        "label": "gprpy.toolbox.gprpyTools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gprpy.toolbox.gprpyTools",
        "description": "gprpy.toolbox.gprpyTools",
        "detail": "gprpy.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "gaussian_filter",
        "importPath": "scipy.ndimage",
        "description": "scipy.ndimage",
        "isExtraImport": true,
        "detail": "scipy.ndimage",
        "documentation": {}
    },
    {
        "label": "zoom",
        "importPath": "scipy.ndimage",
        "description": "scipy.ndimage",
        "isExtraImport": true,
        "detail": "scipy.ndimage",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "setuptools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "setuptools",
        "description": "setuptools",
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "csinci",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_fk",
        "description": "csimGPR.irlib.external.mig_fk",
        "peekOfCode": "def csinci():\n    \"\"\" Complex valued sinc function interpolation.\n    trout = csinci(trin, t, tout, sizetable)\n    \"\"\"\ndef fktran(D, t, x, ntpad=None, nxpad=None, percent=0., ishift=1):\n    \"\"\" F-K transform using fft on time domain and ifft on space domain. \"\"\"\n    nsamp = D.shape[0]\n    ntr = D.shape[1]\n    if len(t) != nsamp:\n        raise Exception('Time domain length is inconsistent in input')",
        "detail": "csimGPR.irlib.external.mig_fk",
        "documentation": {}
    },
    {
        "label": "fktran",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_fk",
        "description": "csimGPR.irlib.external.mig_fk",
        "peekOfCode": "def fktran(D, t, x, ntpad=None, nxpad=None, percent=0., ishift=1):\n    \"\"\" F-K transform using fft on time domain and ifft on space domain. \"\"\"\n    nsamp = D.shape[0]\n    ntr = D.shape[1]\n    if len(t) != nsamp:\n        raise Exception('Time domain length is inconsistent in input')\n    if len(x) != ntr:\n        raise Exception('Space domain length is inconsistent in input')\n    if ntpad is None:\n        ntpad = 2**nextpow2(t)",
        "detail": "csimGPR.irlib.external.mig_fk",
        "documentation": {}
    },
    {
        "label": "fftrl",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_fk",
        "description": "csimGPR.irlib.external.mig_fk",
        "peekOfCode": "def fftrl(s, t, percent=0.0, n=None):\n    \"\"\" Returns the real part of the forward Fourier transform. \"\"\"\n    # Determine the number of traces in ensemble\n    l = s.shape[0]\n    m = s.shape[1]\n    ntraces = 1\n    itr = 0                             # transpose flag\n    if l == 1:\n        nsamps = m\n        itr = 1",
        "detail": "csimGPR.irlib.external.mig_fk",
        "documentation": {}
    },
    {
        "label": "ifktran",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_fk",
        "description": "csimGPR.irlib.external.mig_fk",
        "peekOfCode": "def ifktran(spec, f, kx, nfpad=None, nkpad=None, percent=0.0):\n    \"\"\" Inverse f-k transform.\n        Arguments:\n            spec    complex valued f-k series\n            f       frequency components for rows of spec\n            kx      wavenumber components for columns of spec\n            nfpad   size to pad spec rows to\n            nkpad   size to pad spec columns to\n            percent controls cosine taper\n        Returns:",
        "detail": "csimGPR.irlib.external.mig_fk",
        "documentation": {}
    },
    {
        "label": "ifftrl",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_fk",
        "description": "csimGPR.irlib.external.mig_fk",
        "peekOfCode": "def ifftrl(spec, f):\n    \"\"\" Inverse Fourier transform for real-valued series.\n        Arguments:\n            spec    input spectrum\n            f       input frequency coordinates\n        Returns:\n            r       output trace\n            t       output time vector\n    \"\"\"\n    m,n = spec.shape            # Will be a problem if spec is 1-dimensional",
        "detail": "csimGPR.irlib.external.mig_fk",
        "documentation": {}
    },
    {
        "label": "mwindow",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_fk",
        "description": "csimGPR.irlib.external.mig_fk",
        "peekOfCode": "def mwindow(n, percent=10.):\n    \"\"\" Creates a boxcar window with raised-cosine tapers. \"\"\"\n    if type(n) is not int and type(n) is not float:\n        n = len(n)\n    # Compute the hanning function\n    if percent > 50. or percent < 0.:\n        raise Exception('Invalid percent in function mwindow (={0})'.format(percent))\n    m = 2.0 * math.floor(percent * n / 100.)\n    h = np.hanning(m)\n    return np.hstack([h[:m/2], np.ones([n-m]), h[m/2:]])",
        "detail": "csimGPR.irlib.external.mig_fk",
        "documentation": {}
    },
    {
        "label": "mwhalf",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_fk",
        "description": "csimGPR.irlib.external.mig_fk",
        "peekOfCode": "def mwhalf(n, percent=10.):\n    \"\"\" Half mwindow. \"\"\"\n    if type(n) is not int and type(n) is not float:\n        n = len(n)\n    # Compute the hanning function\n    if percent > 100. or percent < 0.:\n        raise Exception('Invalid percent in function mwhalf (={0})'.format(percent))\n    m = int(math.floor(percent * n / 100.))\n    h = np.hanning(2*m)\n    return np.hstack([np.ones([n-m]), h[m:0:-1]])",
        "detail": "csimGPR.irlib.external.mig_fk",
        "documentation": {}
    },
    {
        "label": "nextpow2",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_fk",
        "description": "csimGPR.irlib.external.mig_fk",
        "peekOfCode": "def nextpow2(a):\n    \"\"\" Gives the next power of 2 larger than a. \"\"\"\n    return np.ceil(np.log(a) / np.log(2)).astype(int)\ndef fkmig(D, dt, dx, v, params=None):\n    nsamp = D.shape[0]\n    ntr = D.shape[1]\n    t = np.arange(0, nsamp) * dt\n    x = np.arange(0, ntr) * dx\n    interpolated = True\n    fnyq = 1.0 / (2.0*dt)",
        "detail": "csimGPR.irlib.external.mig_fk",
        "documentation": {}
    },
    {
        "label": "fkmig",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_fk",
        "description": "csimGPR.irlib.external.mig_fk",
        "peekOfCode": "def fkmig(D, dt, dx, v, params=None):\n    nsamp = D.shape[0]\n    ntr = D.shape[1]\n    t = np.arange(0, nsamp) * dt\n    x = np.arange(0, ntr) * dx\n    interpolated = True\n    fnyq = 1.0 / (2.0*dt)\n    knyq = 1.0 / (2.0*dx)\n    tmax = t[-1]\n    xmax = abs(x[-1]-x[0])",
        "detail": "csimGPR.irlib.external.mig_fk",
        "documentation": {}
    },
    {
        "label": "calc_toffset",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_kirchoff",
        "description": "csimGPR.irlib.external.mig_kirchoff",
        "peekOfCode": "def calc_toffset(X, T, xoffset=12.0, v=1.68e8):\n    \"\"\" Perform normal move-out and calculate a diffraction hyperbola.\n        X           vector of horizontal offsets\n        T           vector of time offsets\n    Return an array of one-sided vertical offsets in terms of time.\n    \"\"\"\n    # Define arrays of time and distance as starting points\n    TT = T.reshape([-1,1]).repeat(len(X), axis=1)\n    XX = X.reshape([1,-1]).repeat(len(T), axis=0)\n    # Perform normal moveout for the given xoffset to get depth",
        "detail": "csimGPR.irlib.external.mig_kirchoff",
        "documentation": {}
    },
    {
        "label": "warp_array_linear",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_kirchoff",
        "description": "csimGPR.irlib.external.mig_kirchoff",
        "peekOfCode": "def warp_array_linear(A, T, i):\n    \"\"\" Warp an array A by shifting the values up by elements in array T. \"\"\"\n    if A.shape != T.shape:\n        raise Exception('warp_array: A and T must have identical dimensions')\n        return None\n    x = np.arange(A.shape[1])\n    y = np.arange(A.shape[0])\n    X, Y = np.meshgrid(x, y)\n    Y_warp = Y + T\n    W = np.zeros(A.shape)",
        "detail": "csimGPR.irlib.external.mig_kirchoff",
        "documentation": {}
    },
    {
        "label": "mirror",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_kirchoff",
        "description": "csimGPR.irlib.external.mig_kirchoff",
        "peekOfCode": "def mirror(arr):\n    return np.stack([arr[:0:-1], arr])\ndef mig_kirchoff(D, X, T, v=1.68e8, xoffset=12.0, xwindow=50.0, pad_spacing=1.0):\n    \"\"\" Perform Kerchoff migration on a 2D line.\n    Requires\n        D           2D array of traces\n        X           vector of horizontal offsets\n        T           vector of time offsets\n    Optionally also takes\n        v           wave velocity (m/s, assumed to be for ice)",
        "detail": "csimGPR.irlib.external.mig_kirchoff",
        "documentation": {}
    },
    {
        "label": "mig_kirchoff",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_kirchoff",
        "description": "csimGPR.irlib.external.mig_kirchoff",
        "peekOfCode": "def mig_kirchoff(D, X, T, v=1.68e8, xoffset=12.0, xwindow=50.0, pad_spacing=1.0):\n    \"\"\" Perform Kerchoff migration on a 2D line.\n    Requires\n        D           2D array of traces\n        X           vector of horizontal offsets\n        T           vector of time offsets\n    Optionally also takes\n        v           wave velocity (m/s, assumed to be for ice)\n        xoffset     transmitter-reciever spacing (m)\n        xwindow     half the horizontal window to be considered for migration",
        "detail": "csimGPR.irlib.external.mig_kirchoff",
        "documentation": {}
    },
    {
        "label": "test1",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_kirchoff",
        "description": "csimGPR.irlib.external.mig_kirchoff",
        "peekOfCode": "def test1():\n    # Test function\n    X = np.arange(0.0, 300.0, 4.0)\n    dt = 1e-8\n    T = np.arange(0.0, 256*dt, dt)\n    THYP = calc_toffset(X, T)\n    print(THYP.max(), THYP.min(), THYP.mean())\n    plt.figure()\n    plt.imshow(THYP)\n    plt.axis('tight')",
        "detail": "csimGPR.irlib.external.mig_kirchoff",
        "documentation": {}
    },
    {
        "label": "test2",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_kirchoff",
        "description": "csimGPR.irlib.external.mig_kirchoff",
        "peekOfCode": "def test2():\n    import irlib\n    INFILE = '../field/radar_200905/Glacier2/Glacier2_May09_utm.h5'\n    S = irlib.Survey(INFILE)\n    L = S.ExtractLine(1)\n    L.DoTimeGainControl()\n    D = L.data.copy()\n    eastings, northings, p = L.LineProject()\n    P = np.sqrt((eastings-eastings[0])**2 + (northings-northings[0])**2)\n    T = np.arange(L.data.shape[0]) * 1e-8",
        "detail": "csimGPR.irlib.external.mig_kirchoff",
        "documentation": {}
    },
    {
        "label": "test3",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_kirchoff",
        "description": "csimGPR.irlib.external.mig_kirchoff",
        "peekOfCode": "def test3():\n    # Test on synthetic planes\n    D = np.zeros([256, 256])\n    D[63,5:251] = 1\n    D[127,5:251] = 1\n    D[191,5:251] = 1\n    P = np.arange(0, 512, 2)\n    T = np.arange(256) * 1e-8\n    Dmig = mig_kirchoff(D, P, T, xoffset=15.0)\n    plt.figure()",
        "detail": "csimGPR.irlib.external.mig_kirchoff",
        "documentation": {}
    },
    {
        "label": "test4",
        "kind": 2,
        "importPath": "csimGPR.irlib.external.mig_kirchoff",
        "description": "csimGPR.irlib.external.mig_kirchoff",
        "peekOfCode": "def test4():\n    # Test on synthetic slopes\n    D = np.zeros([256, 256])\n    for r in range(5,251):\n        for c in range(60,81):\n            if r == round(0.1*c + 60):\n                D[r,c] = 1\n    for r in range(5,251):\n        for c in range(160,181):\n            if r == round(0.1*c + 160):",
        "detail": "csimGPR.irlib.external.mig_kirchoff",
        "documentation": {}
    },
    {
        "label": "Bscan_migration_v3",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.Bscan_migration_v3",
        "description": "csimGPR.kirchhoffmigration.Bscan_migration_v3",
        "peekOfCode": "def Bscan_migration_v3(B, h, er, t, x, tx_pos, rx_pos, xQ, zQ, progress=True):\n    c = 3e8\n    NxQ = len(xQ)\n    NzQ = len(zQ)\n    x_lims = 0.5\n    dx = x[1] - x[0]\n    xc = np.arange(-x_lims, x_lims, dx)\n    Nxc = len(xc)\n    TTD_inds = np.zeros((Nxc, NzQ), dtype=np.uint32)\n    for ii in range(Nxc):",
        "detail": "csimGPR.kirchhoffmigration.Bscan_migration_v3",
        "documentation": {}
    },
    {
        "label": "GPR_transmission_angles_v4",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.GPR_transmission_angles_v4",
        "description": "csimGPR.kirchhoffmigration.GPR_transmission_angles_v4",
        "peekOfCode": "def GPR_transmission_angles_v4(er, h, xa, ya, xq, yq, zq):\n    xa = np.single(xa)\n    ya = np.single(ya)\n    xq = np.single(xq)\n    yq = np.single(yq)\n    max_n_steps = 50\n    yq = yq - ya\n    xq = xq - xa\n    phi = np.arctan2(yq, xq)\n    if phi < 0:",
        "detail": "csimGPR.kirchhoffmigration.GPR_transmission_angles_v4",
        "documentation": {}
    },
    {
        "label": "Scan",
        "kind": 6,
        "importPath": "csimGPR.kirchhoffmigration.Scan",
        "description": "csimGPR.kirchhoffmigration.Scan",
        "peekOfCode": "class Scan:\n    def __init__(self, ScanData, xVec, tVec):\n        if ScanData is not None:\n            self.Data = ScanData        # 原始数据，时间作为行，x作为列\n            self.x = xVec               # x坐标\n            self.dx = xVec[1] - xVec[0] # x坐标间隔\n            self.Kx = 1 / self.dx       # x波数\n            self.Nx = len(xVec)         # x坐标点数\n            self.kx = np.linspace(-self.Kx/2, self.Kx/2, self.Nx)   # x波数坐标\n            self.t = tVec               # 时间坐标",
        "detail": "csimGPR.kirchhoffmigration.Scan",
        "documentation": {}
    },
    {
        "label": "find_image_resolution_slices",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.find_image_resolution_slices",
        "description": "csimGPR.kirchhoffmigration.find_image_resolution_slices",
        "peekOfCode": "def find_image_resolution_slices(I):\n    \"\"\"\n    此函数将查找目标图像中的最大值并提取水平和垂直切片。\n    参数：\n    I - 图像\n    返回值：\n    vslice - 垂直切片\n    hslice - 水平切片\n    \"\"\"\n    # 查找图像的维度",
        "detail": "csimGPR.kirchhoffmigration.find_image_resolution_slices",
        "documentation": {}
    },
    {
        "label": "PlotSpectrum",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "description": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "peekOfCode": "def PlotSpectrum(trace):\n    '''\n    calculate and plot frequency spectrum of a single trace\n    '''\n    # use unfiltered data for that\n    f = open('SEIS-orig', 'r')\n    # read data in ieee754 format\n    inputs = np.fromfile(f, dtype=np.float32)\n    # reshape\n    data = inputs.reshape(noff,ntrc,nsmp)",
        "detail": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "documentation": {}
    },
    {
        "label": "PlotImg",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "description": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "peekOfCode": "def PlotImg(data2d,name, ndepth,colormap, nx=1, nz=300, dt=0.002, dx=20, dz=10, dcdp=20, offsets=np.array([0, 500, 1000, 1500, 2000])):\n    noff, ntrc, _ = data2d.shape\n    data2d = data2d.reshape(noff*ntrc,ndepth)\n    filepath = \"./\" + name + \".png\"\n    plt.figure()\n    imgplot = plt.imshow(data2d.T, extent=[0,ntrc*dx*noff, nz*dz,0],cmap=colormap)\n    # lines and offsets\n    for i in range(noff):\n        plt.axvline(linewidth=2, color='k',x=(i+1)*ntrc*dx)\n        plt.text((i+1)*ntrc*dx-ntrc*dx/2,nz*dz+50,offsets[i],verticalalignment='top',horizontalalignment='center')        #custom axis",
        "detail": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "documentation": {}
    },
    {
        "label": "Migrate",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "description": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "peekOfCode": "def Migrate(data,nx,dx,nz,dz,dt,dcdp,v,offsets,nsmp,ntrc,noff,ioff):\n    R = np.zeros((nx, nz))\n    for ix in range(0, nx):        #loop over discreticized undergroundpoints in x\n        x = dx*ix\n        for iz in range(1, nz):    #loop over discreticized undergroundpoints in z\n            z = dz*iz               #(depth)\n            for itrc in range(0, ntrc):     #loop over all traces\n                ksi = dcdp * itrc           # cdp point\n                # h = offsets[ioff]//2         # half offset\n                h = offsets[ioff]/2         # half offset",
        "detail": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "documentation": {}
    },
    {
        "label": "benchmarkfunc",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "description": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "peekOfCode": "def benchmarkfunc(mode):\n    nx=1\n    if (mode == 'python'):\n        R = Migrate(data,nx,dx,nz,dz,dt,dcdp,3000,offsets,nsmp,ntrc,noff,1)\n    if (mode == 'cython'):\n        R = mod_cyMigrate.cyMigrate(data,nx,dx,nz,dz,dt,dcdp,3000,offsets,nsmp,ntrc,noff,1)\ndef benchmark():\n    import timeit\n    nx = 1\n    print(\"Benchmarking python vs cython:\")",
        "detail": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "documentation": {}
    },
    {
        "label": "benchmark",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "description": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "peekOfCode": "def benchmark():\n    import timeit\n    nx = 1\n    print(\"Benchmarking python vs cython:\")\n    print(\"Migrating 10 times with nx=\",nx)\n    print(\"python code:\")\n    py_time = timeit.timeit(\"kirchhoffmigration.benchmarkfunc('python')\",setup=\"import kirchhoffmigration\", number=10)\n    print(py_time)\n    print(\"cython code:\")\n    cy_time = timeit.timeit(\"kirchhoffmigration.benchmarkfunc('cython')\",setup=\"import kirchhoffmigration\", number=10)",
        "detail": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "documentation": {}
    },
    {
        "label": "v_analysis",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "description": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "peekOfCode": "def v_analysis(vmin, vmax):\n    '''\n    Velocity analysis due to testing a range of velocities (from vmin to vmax)\n    plotting them together in one plot.\n    '''\n    nvels = 100                         # number of velocities to be tested\n    V = np.linspace(vmin,vmax,nvels)\n    nx=1                                # only compute one trace\n    M = np.zeros((nz, nvels))\n    for n in range(0, len(V)-1):",
        "detail": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "documentation": {}
    },
    {
        "label": "full_migration",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "description": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "peekOfCode": "def full_migration(data):\n    nx = ntrc\n    V = 2950\n    R = np.zeros((noff,nx, nz))\n    for ioff in range(noff):            # each offset in its own layer\n        R[ioff,:,:] = mod_cyMigrate.cyMigrate(data,nx,dx,nz,dz,dt,dcdp,V,offsets,nsmp,ntrc,noff,ioff)\n    return R\n# def full_migration(data=None, \n#                     nx=None, nz=None, noff=None, ntrc=None, nsmp=None,\n#                     dx=None, dz=None, dt=None, dcdp=None, ",
        "detail": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "documentation": {}
    },
    {
        "label": "plot_offsets",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "description": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "peekOfCode": "def plot_offsets(data,name):\n    data2d = data.reshape(noff*ntrc,nz)\n    filepath = \"./figures/\" + name + \".eps\"\n    plt.figure()\n    plt.imshow(data2d.T, extent=[0,ntrc*dx*noff, nz*dz,0], cmap=colormap)\n    # lines and offsets\n    for i in range(noff):\n        plt.axvline(linewidth=2, color='k',x=(i+1)*ntrc*dx)\n        plt.text((i+1)*ntrc*dx-ntrc*dx/2,nz*dz+50,offsets[i],verticalalignment='top',horizontalalignment='center')        #custom axis\n    # new x axis",
        "detail": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "documentation": {}
    },
    {
        "label": "taper",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "description": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "peekOfCode": "def taper(data,traces=20):\n    '''\n    Tapers the data to reduce migration artifacts via sinus curve.\n    Optional Parameter traces: Number of traces to be affected.\n    '''\n    noff, ntrc, _ = data.shape\n    amount = list()\n    i = 0\n    for x in np.linspace(0, np.pi/2,traces):\n        amount.append(np.sin(x))",
        "detail": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "documentation": {}
    },
    {
        "label": "check_amplitudes",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "description": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "peekOfCode": "def check_amplitudes(data):\n    maxamp = np.zeros((noff, data.shape[1]))\n    for ioff in range(noff):\n        for i in range(0,data.shape[1]):\n            maxamp[ioff,i] = (max(abs(data[ioff,i,:])))\n    #plot\n    colors = [\"#a5b7e6\",\"#274db3\",\"#296f80\",\"#8d6450\",\"#b34127\"]\n    plt.figure()\n    for i in range(noff):\n        plt.plot(range(data.shape[1]),maxamp[i,:],colors[i],label=\"Offset %dm\"%(i*500),linewidth=2)",
        "detail": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "documentation": {}
    },
    {
        "label": "v_analysis2",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "description": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "peekOfCode": "def v_analysis2(data,h1,h2,v):\n    nx=1\n    off1 = mod_cyMigrate.cyMigrate(data,nx,dx,nz,dz,dt,dcdp,v,offsets,nsmp,ntrc,noff,h1)\n    off2 = mod_cyMigrate.cyMigrate(data,nx,dx,nz,dz,dt,dcdp,v,offsets,nsmp,ntrc,noff,h2)\n    zm1 = np.argmax(off1)*dz\n    zm2 = np.argmax(off2)*dz\n    h12 = (offsets[h1]/2)**2\n    h22 = (offsets[h2]/2)**2\n    print(zm1,zm2,h12,h22)\n    v0 = v * (np.sqrt((zm1**2 - zm2**2)/(h12-h22) +1 ))**-1",
        "detail": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "documentation": {}
    },
    {
        "label": "plot_zm",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "description": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "peekOfCode": "def plot_zm():\n    z0 = 1\n    v0 = 1\n    hlist = np.linspace(0,3,100)\n    zm = np.zeros((3,100))\n    i=0\n    n=0\n    for vm in [0.9*v0, v0, 1.1*v0]:\n        for h in hlist:\n            zm[i,n] = np.sqrt(vm**2 * (h**2+z0**2)/(v0**2)-h**2)",
        "detail": "csimGPR.kirchhoffmigration.kirchhoffmigration",
        "documentation": {}
    },
    {
        "label": "min1",
        "kind": 2,
        "importPath": "csimGPR.kirchhoffmigration.min1",
        "description": "csimGPR.kirchhoffmigration.min1",
        "peekOfCode": "def min1(t, M):\n    # t is sorted with variation along dim3\n    # M is the object to match to\n    Np = len(t)-1\n    lo = 0\n    hi = Np\n    while lo < hi:\n        mid = np.int(np.floor((lo + hi) / 2))\n        tq = t[mid]\n        if tq == M:",
        "detail": "csimGPR.kirchhoffmigration.min1",
        "documentation": {}
    },
    {
        "label": "ext",
        "kind": 5,
        "importPath": "csimGPR.kirchhoffmigration.setup",
        "description": "csimGPR.kirchhoffmigration.setup",
        "peekOfCode": "ext = Extension(\"mod_cyMigrate\", [\"mod_cyMigrate.pyx\"],\n    include_dirs = [np.get_include()])\n## Cython.Distutils.build_ext 类是用于构建 Cython 扩展模块的工具，\n## 用于将 Cython 代码 (.pyx) 编译成 C 代码 (.c)，并将其与可执行的 C 代码一起编译成最终的扩展模块。\nsetup(ext_modules=[ext],\n      cmdclass = {'build_ext': build_ext})",
        "detail": "csimGPR.kirchhoffmigration.setup",
        "documentation": {}
    },
    {
        "label": "read2A",
        "kind": 2,
        "importPath": "csimGPR.toolbox..ipynb_checkpoints.gprIO_2A-checkpoint",
        "description": "csimGPR.toolbox..ipynb_checkpoints.gprIO_2A-checkpoint",
        "peekOfCode": "def read2A(filename=None):\n    import struct\n    import os\n    ScanNum = 1063\n    RecLen = 8283\n    SampleNum = 2048\n    RecOffset = 90\n    LabNum = 0\n    DatclonNum = ScanNum - 1  # LabNum + DatclonNum = ScanNum\n    path = os.getcwd()",
        "detail": "csimGPR.toolbox..ipynb_checkpoints.gprIO_2A-checkpoint",
        "documentation": {}
    },
    {
        "label": "readdt1",
        "kind": 2,
        "importPath": "csimGPR.toolbox..ipynb_checkpoints.gprIO_DT1-checkpoint",
        "description": "csimGPR.toolbox..ipynb_checkpoints.gprIO_DT1-checkpoint",
        "peekOfCode": "def readdt1(filename):\n    '''\n    Reads the Sensors and Software .DT1 data files. This function is\n    a Python translation of http://www.lucabaradello.it/files/dt1read.m\n    INPUT: \n    filename      data file name including the .DT1 extension\n    OUTPUT:\n    data          data matrix whose columns contain the traces\n    '''\n    # This function is a python translation of dt1read.m from",
        "detail": "csimGPR.toolbox..ipynb_checkpoints.gprIO_DT1-checkpoint",
        "documentation": {}
    },
    {
        "label": "readdt1Header",
        "kind": 2,
        "importPath": "csimGPR.toolbox..ipynb_checkpoints.gprIO_DT1-checkpoint",
        "description": "csimGPR.toolbox..ipynb_checkpoints.gprIO_DT1-checkpoint",
        "peekOfCode": "def readdt1Header(filename):\n    '''\n    Reads the Sensors and Software .HD header files.\n    INPUT: \n    filename      header file name including the .HD extension\n    OUTPUT:\n    info          dict with information from the header\n    '''\n    info = {}\n    with open(filename,\"r\",newline='\\n') as datafile:",
        "detail": "csimGPR.toolbox..ipynb_checkpoints.gprIO_DT1-checkpoint",
        "documentation": {}
    },
    {
        "label": "showSplash",
        "kind": 2,
        "importPath": "csimGPR.toolbox..ipynb_checkpoints.splash-checkpoint",
        "description": "csimGPR.toolbox..ipynb_checkpoints.splash-checkpoint",
        "peekOfCode": "def showSplash(a,dir_path,widfac,highfac,fontfac):\n    '''\n    Creates the splash screen shown when starting GPRPy GUI for \n    common-offset profiles.\n    '''\n    try:\n        filename=os.path.join(dir_path,'exampledata','SnS','ComOffs','XLINE00.DT1')\n        snakeGPR = gp.gprpyProfile(filename)\n        maxpoint=100;\n        x=snakeGPR.twtt[0:maxpoint]",
        "detail": "csimGPR.toolbox..ipynb_checkpoints.splash-checkpoint",
        "documentation": {}
    },
    {
        "label": "Nonnegative_Matrix_Factorization",
        "kind": 2,
        "importPath": "csimGPR.toolbox.Robust_NMF",
        "description": "csimGPR.toolbox.Robust_NMF",
        "peekOfCode": "def Nonnegative_Matrix_Factorization(v,rank,max_iter=1000):\n    w=np.random.rand(v.shape[0],rank)\n    h=np.random.rand(rank,v.shape[1])\n    for idx in range(max_iter):\n        w=np.multiply(w,(np.dot(v,h.T)/(np.dot(w,np.dot(h,h.T))+1e-8)))\n        h=np.multiply(h,(np.dot(w.T,v)/(np.dot(w.T,np.dot(w,h))+1e-8)))\n    return w,h\ndef shrink(M,tau):\n    return np.sign(M)*np.maximum((np.abs(M)-tau),np.zeros(M.shape))\ndef Updata_WH(X,S,w,h):",
        "detail": "csimGPR.toolbox.Robust_NMF",
        "documentation": {}
    },
    {
        "label": "shrink",
        "kind": 2,
        "importPath": "csimGPR.toolbox.Robust_NMF",
        "description": "csimGPR.toolbox.Robust_NMF",
        "peekOfCode": "def shrink(M,tau):\n    return np.sign(M)*np.maximum((np.abs(M)-tau),np.zeros(M.shape))\ndef Updata_WH(X,S,w,h):\n    w=np.multiply(w,(np.abs(np.dot(S-X,h.T))-np.dot(S-X,h.T))/(2*np.dot(w,np.dot(h,h.T))+1e-8))\n    h=np.multiply(h,(np.abs(np.dot(w.T,S-X))-np.dot(w.T,S-X))/(2*np.dot(w.T,np.dot(w,h))+1e-8))\n    norm_=np.sqrt(np.sum(w**2))\n    w=w/norm_\n    h=h*norm_\n    return w,h\ndef Robust_NMF(X,lambda_=5e-2,max_iter=1000,rank=1):",
        "detail": "csimGPR.toolbox.Robust_NMF",
        "documentation": {}
    },
    {
        "label": "Updata_WH",
        "kind": 2,
        "importPath": "csimGPR.toolbox.Robust_NMF",
        "description": "csimGPR.toolbox.Robust_NMF",
        "peekOfCode": "def Updata_WH(X,S,w,h):\n    w=np.multiply(w,(np.abs(np.dot(S-X,h.T))-np.dot(S-X,h.T))/(2*np.dot(w,np.dot(h,h.T))+1e-8))\n    h=np.multiply(h,(np.abs(np.dot(w.T,S-X))-np.dot(w.T,S-X))/(2*np.dot(w.T,np.dot(w,h))+1e-8))\n    norm_=np.sqrt(np.sum(w**2))\n    w=w/norm_\n    h=h*norm_\n    return w,h\ndef Robust_NMF(X,lambda_=5e-2,max_iter=1000,rank=1):\n    w,h=Nonnegative_Matrix_Factorization(X,rank)\n    for idx in range(max_iter):",
        "detail": "csimGPR.toolbox.Robust_NMF",
        "documentation": {}
    },
    {
        "label": "Robust_NMF",
        "kind": 2,
        "importPath": "csimGPR.toolbox.Robust_NMF",
        "description": "csimGPR.toolbox.Robust_NMF",
        "peekOfCode": "def Robust_NMF(X,lambda_=5e-2,max_iter=1000,rank=1):\n    w,h=Nonnegative_Matrix_Factorization(X,rank)\n    for idx in range(max_iter):\n        S=X-np.dot(w,h)\n        S=shrink(S,lambda_/2)\n        w,h=Updata_WH(X,S,w,h)\n    return w,h,S\ndef PreProcessGPR(X_data,lambda_,max_iter,rank):\n    if np.min(X_data)<0:\n        min_X_data=np.min(X_data)",
        "detail": "csimGPR.toolbox.Robust_NMF",
        "documentation": {}
    },
    {
        "label": "PreProcessGPR",
        "kind": 2,
        "importPath": "csimGPR.toolbox.Robust_NMF",
        "description": "csimGPR.toolbox.Robust_NMF",
        "peekOfCode": "def PreProcessGPR(X_data,lambda_,max_iter,rank):\n    if np.min(X_data)<0:\n        min_X_data=np.min(X_data)\n    else:\n        min_X_data=0\n    X_data-=min_X_data\n    w,h,S=Robust_NMF(X_data,lambda_=lambda_,max_iter=max_iter,rank=rank)\n    X_data+=min_X_data\n    RefData=X_data-S\n    return RefData",
        "detail": "csimGPR.toolbox.Robust_NMF",
        "documentation": {}
    },
    {
        "label": "resource_path",
        "kind": 2,
        "importPath": "csimGPR.toolbox.csimStartGUI",
        "description": "csimGPR.toolbox.csimStartGUI",
        "peekOfCode": "def resource_path(relative_path):\n    \"\"\" Get absolute path to resource, works for dev and for PyInstaller \"\"\"\n    base_path = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))\n    return os.path.join(base_path, relative_path)\ndef showcsimGPR(a,dir_path,widfac,highfac,fontfac):\n    '''\n    Creates the csimGPR screen shown when starting csimGPR GUI for \n    common-offset profiles.\n    '''\n    try:",
        "detail": "csimGPR.toolbox.csimStartGUI",
        "documentation": {}
    },
    {
        "label": "showcsimGPR",
        "kind": 2,
        "importPath": "csimGPR.toolbox.csimStartGUI",
        "description": "csimGPR.toolbox.csimStartGUI",
        "peekOfCode": "def showcsimGPR(a,dir_path,widfac,highfac,fontfac):\n    '''\n    Creates the csimGPR screen shown when starting csimGPR GUI for \n    common-offset profiles.\n    '''\n    try:\n        filename=os.path.join(dir_path,'exampledata','SnS','ComOffs','XLINE00.DT1')\n        snakeGPR = gp.gprpyProfile(filename)\n        maxpoint=100;\n        x=snakeGPR.twtt[0:maxpoint]",
        "detail": "csimGPR.toolbox.csimStartGUI",
        "documentation": {}
    },
    {
        "label": "butterworth",
        "kind": 2,
        "importPath": "csimGPR.toolbox.filters",
        "description": "csimGPR.toolbox.filters",
        "peekOfCode": "def butterworth(data, cutoff, fs, order=6, btype=\"bandpass\", axis=0):\n    \"\"\"csimGPR/toolbox/filters.py made by Zhiyu Zhang JiLin University in 2023-07-18 15h.\n    Butterworth sosfiltfilt (forward-backward filter).\n    Parameters\n    ----------\n    data : numpy array\n        Array shape N,D\n    cutoff : float or tuple of float\n        Cutoff frequency for the filter\n        A float for a lowpass and a highpass filters",
        "detail": "csimGPR.toolbox.filters",
        "documentation": {}
    },
    {
        "label": "read2A",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprIO_2A",
        "description": "csimGPR.toolbox.gprIO_2A",
        "peekOfCode": "def read2A(filename=None):\n    \"\"\"csimGPR/toolbox/gprIO_2A.py made by Zhiyu Zhang JiLin University in 2023-07-18 15h.\n    Parameters\n    ----------\n    data : numpy array\n        Array shape N,D\n    cutoff : float or tuple of float\n        Cutoff frequency for the filter\n        A float for a lowpass and a highpass filters\n        A tuple (lower, upper) for a bandpass and bandstop filters",
        "detail": "csimGPR.toolbox.gprIO_2A",
        "documentation": {}
    },
    {
        "label": "readMars2A",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprIO_2A_Mars",
        "description": "csimGPR.toolbox.gprIO_2A_Mars",
        "peekOfCode": "def readMars2A(filename=None):\n    \"\"\"csimGPR/toolbox/gprIO_2A_Mars.py made by Zhiyu Zhang JiLin University in 2023-07-18 15h.\n    Parameters\n    ----------\n    data : numpy array\n        Array shape N,D\n    cutoff : float or tuple of float\n        Cutoff frequency for the filter\n        A float for a lowpass and a highpass filters\n        A tuple (lower, upper) for a bandpass and bandstop filters",
        "detail": "csimGPR.toolbox.gprIO_2A_Mars",
        "documentation": {}
    },
    {
        "label": "read2B",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprIO_2B",
        "description": "csimGPR.toolbox.gprIO_2B",
        "peekOfCode": "def read2B(filename=None):\n    # 设置读取的精度\n    precision4 = 'f'  # 单精度浮点数，对应于MATLAB中的single\n    skip4 = 69\n    # 初始化列表以存放数据\n    D_all = []\n    E_all = []\n    with open(filename, 'rb') as fid:\n        # 首先跳过文件开始的18个字节\n        fid.seek(18)",
        "detail": "csimGPR.toolbox.gprIO_2B",
        "documentation": {}
    },
    {
        "label": "readBSQ",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprIO_BSQ",
        "description": "csimGPR.toolbox.gprIO_BSQ",
        "peekOfCode": "def readBSQ(file_name):\n    '''\n    Reads the ENVI standard BSQ files. The file extension for the \n    data needs to be \".dat\" and the extension for the header needs \n    to be \".GPRhdr\" \n    INPUT: \n    file_name      data file name without the extension!\n    OUTPUT:\n    data          data matrix whose columns contain the traces\n    info          dict with information from the header",
        "detail": "csimGPR.toolbox.gprIO_BSQ",
        "documentation": {}
    },
    {
        "label": "readGPRhdr",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprIO_BSQ",
        "description": "csimGPR.toolbox.gprIO_BSQ",
        "peekOfCode": "def readGPRhdr(filename):\n    '''\n    Reads the ENVI standard BSQ file header\n    INPUT: \n    filename      file name for header with extension\n    OUTPUT:\n    info          dict with information from the header\n    '''\n    # Read in text file\n    info = {}",
        "detail": "csimGPR.toolbox.gprIO_BSQ",
        "documentation": {}
    },
    {
        "label": "readdt1",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprIO_DT1",
        "description": "csimGPR.toolbox.gprIO_DT1",
        "peekOfCode": "def readdt1(filename):\n    '''\n    Reads the Sensors and Software .DT1 data files. This function is\n    a Python translation of http://www.lucabaradello.it/files/dt1read.m\n    INPUT: \n    filename      data file name including the .DT1 extension\n    OUTPUT:\n    data          data matrix whose columns contain the traces\n    '''\n    # This function is a python translation of dt1read.m from",
        "detail": "csimGPR.toolbox.gprIO_DT1",
        "documentation": {}
    },
    {
        "label": "readdt1Header",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprIO_DT1",
        "description": "csimGPR.toolbox.gprIO_DT1",
        "peekOfCode": "def readdt1Header(filename):\n    '''\n    Reads the Sensors and Software .HD header files.\n    INPUT: \n    filename      header file name including the .HD extension\n    OUTPUT:\n    info          dict with information from the header\n    '''\n    info = {}\n    with open(filename,\"r\",newline='\\n') as datafile:",
        "detail": "csimGPR.toolbox.gprIO_DT1",
        "documentation": {}
    },
    {
        "label": "readdzt",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprIO_DZT",
        "description": "csimGPR.toolbox.gprIO_DZT",
        "peekOfCode": "def readdzt(filename):\n    '''\n    Reads a GSSI .DZT data file. \n    INPUT: \n    filename     data file name including .DZT extension\n    OUTPUT:\n    data          data matrix whose columns contain the traces\n    info          dict with information from the header\n    Thanks to Ian Nesbitt for pointing out extended headers and\n    providing the documentation file.",
        "detail": "csimGPR.toolbox.gprIO_DZT",
        "documentation": {}
    },
    {
        "label": "readMALA",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprIO_MALA",
        "description": "csimGPR.toolbox.gprIO_MALA",
        "peekOfCode": "def readMALA(file_name):\n    '''\n    Reads the MALA .rd3 data file and the .rad header. Can also be used\n    to read .rd7 files but I'm not sure if they are really organized\n    the same way.\n    INPUT: \n    file_name     data file name without the extension!\n    OUTPUT:\n    data          data matrix whose columns contain the traces\n    info          dict with information from the header",
        "detail": "csimGPR.toolbox.gprIO_MALA",
        "documentation": {}
    },
    {
        "label": "readGPRhdr",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprIO_MALA",
        "description": "csimGPR.toolbox.gprIO_MALA",
        "peekOfCode": "def readGPRhdr(filename):\n    '''\n    Reads the MALA header\n    INPUT: \n    filename      file name for header with .rad extension\n    OUTPUT:\n    info          dict with information from the header\n    '''\n    # Read in text file\n    info = {}",
        "detail": "csimGPR.toolbox.gprIO_MALA",
        "documentation": {}
    },
    {
        "label": "alignTraces",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprpyTools",
        "description": "csimGPR.toolbox.gprpyTools",
        "peekOfCode": "def alignTraces(data):\n    '''\n    Aligns the traces in the profile such that their maximum \n    amplitudes align at the average two-way travel time of the \n    maximum amplitudes \n    INPUT:\n    data       data matrix whose columns contain the traces\n    OUTPUT:\n    newdata    data matrix with aligned traces\n    '''",
        "detail": "csimGPR.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "dewow",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprpyTools",
        "description": "csimGPR.toolbox.gprpyTools",
        "peekOfCode": "def dewow(data,window):\n    '''\n    Subtracts from each sample along each trace an \n    along-time moving average.\n    Can be used as a low-cut filter.\n    INPUT:\n    data       data matrix whose columns contain the traces \n    window     length of moving average window \n               [in \"number of samples\"]\n    OUTPUT:",
        "detail": "csimGPR.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "smooth",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprpyTools",
        "description": "csimGPR.toolbox.gprpyTools",
        "peekOfCode": "def smooth(data,window):\n    '''\n    Replaces each sample along each trace with an \n    along-time moving average.\n    Can be used as high-cut filter.\n    INPUT:\n    data      data matrix whose columns contain the traces \n    window    length of moving average window\n              [in \"number of samples\"]\n    OUTPUT:",
        "detail": "csimGPR.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "remMeanTrace",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprpyTools",
        "description": "csimGPR.toolbox.gprpyTools",
        "peekOfCode": "def remMeanTrace(data,ntraces):\n    '''\n    Subtracts from each trace the average trace over\n    a moving average window.\n    Can be used to remove horizontal arrivals, \n    such as the airwave.\n    INPUT:\n    data       data matrix whose columns contain the traces \n    ntraces    window width; over how many traces \n               to take the moving average.",
        "detail": "csimGPR.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "profileSmooth",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprpyTools",
        "description": "csimGPR.toolbox.gprpyTools",
        "peekOfCode": "def profileSmooth(data,profilePos,ntraces=1,noversample=1):\n    '''\n    First creates copies of each trace and appends the copies \n    next to each trace, then replaces each trace with the \n    average trace over a moving average window.\n    Can be used to smooth-out noisy reflectors appearing \n    in neighboring traces, or simply to increase the along-profile \n    resolution by interpolating between the traces.\n    INPUT:\n    data            data matrix whose columns contain the traces ",
        "detail": "csimGPR.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "tpowGain",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprpyTools",
        "description": "csimGPR.toolbox.gprpyTools",
        "peekOfCode": "def tpowGain(data,twtt,power):\n    '''\n    Apply a t-power gain to each trace with the given exponent.\n    INPUT:\n    data      data matrix whose columns contain the traces\n    twtt      two-way travel time values for the rows in data\n    power     exponent\n    OUTPUT:\n    newdata   data matrix after t-power gain\n    '''",
        "detail": "csimGPR.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "agcGain",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprpyTools",
        "description": "csimGPR.toolbox.gprpyTools",
        "peekOfCode": "def agcGain(data,window):\n    '''\n    Apply automated gain controll (AGC) by normalizing the energy\n    of the signal over a given window width in each trace\n    INPUT:\n    data       data matrix whose columns contain the traces\n    window     window width [in \"number of samples\"]\n    OUTPUT:\n    newdata    data matrix after AGC gain\n    '''",
        "detail": "csimGPR.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "prepTopo",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprpyTools",
        "description": "csimGPR.toolbox.gprpyTools",
        "peekOfCode": "def prepTopo(topofile,delimiter=',',xStart=0):\n    '''\n    Reads an ASCII text file containing either profile/topo coordinates \n    (if given as two columns) or x,y,z or Easting,Northing,Elevation\n    (if given as three columns)\n    INPUT:\n    topofile    file name for the ASCII text file\n    delimiter   delimiter by which the entries are separated \n                (e.g. ',' or tab '\\t') [default: ',']\n    xStart      if three-dimensional topo data is given:",
        "detail": "csimGPR.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "correctTopo",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprpyTools",
        "description": "csimGPR.toolbox.gprpyTools",
        "peekOfCode": "def correctTopo(data, velocity, profilePos, topoPos, topoVal, twtt):\n    '''\n    Corrects for topography along the profile by shifting each \n    Trace up or down depending on provided coordinates.\n    INPUT:\n    data          data matrix whose columns contain the traces\n    velocity      subsurface RMS velocity in m/ns\n    profilePos    along-profile coordinates of the traces\n    topoPos       along-profile coordinates for provided elevation\n                  in meters",
        "detail": "csimGPR.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "prepVTK",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprpyTools",
        "description": "csimGPR.toolbox.gprpyTools",
        "peekOfCode": "def prepVTK(profilePos,gpsmat=None,smooth=True,win_length=51,porder=3):\n    '''\n    Calculates the three-dimensional coordinates for each trace\n    by interpolating the given three dimensional points along the\n    profile.\n    INPUT:\n    profilePos    the along-profile coordinates of the traces\n    gpsmat        n x 3 matrix containing the x, y, z coordinates \n                  of given three-dimensional points for the profile\n    smooth        Want to smooth the profile's three-dimensional alignment",
        "detail": "csimGPR.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "linStackedAmplitude",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprpyTools",
        "description": "csimGPR.toolbox.gprpyTools",
        "peekOfCode": "def linStackedAmplitude(data,profilePos,twtt,vVals,tVals,typefact):\n    '''\n    Calculates the linear stacked amplitudes for each two-way \n    travel time sample and the provided velocity range \n    by summing the pixels of the data that follow a line given \n    by the two-way travel time zero offset and the velocity.\n    INPUT:\n    data          data matrix whose columns contain the traces\n    profilePos    along-profile coordinates of the traces\n    twtt          two-way travel time values for the samples, in ns",
        "detail": "csimGPR.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "hypStackedAmplitude",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprpyTools",
        "description": "csimGPR.toolbox.gprpyTools",
        "peekOfCode": "def hypStackedAmplitude(data,profilePos,twtt,vVals,tVals,typefact):\n    '''\n    Calculates the hyperbolic stacked amplitudes for each two-way \n    travel time sample and the provided velocity range \n    by summing the pixels of the data that follow a hyperbola given \n    by the two-way travel time apex and the velocity.\n    INPUT:\n    data          data matrix whose columns contain the traces\n    profilePos    along-profile coordinates of the traces\n    twtt          two-way travel time values for the samples, in ns",
        "detail": "csimGPR.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "linStackedAmplitude_alt1",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprpyTools",
        "description": "csimGPR.toolbox.gprpyTools",
        "peekOfCode": "def linStackedAmplitude_alt1(data,profilePos,twtt,vVals,tVals,typefact):\n    '''\n    Calculates the linear stacked amplitudes for each two-way \n    travel time sample and the provided velocity range \n    by summing the pixels of the data that follow a line given \n    by the two-way travel time zero offset and the velocity.\n    INPUT:\n    data          data matrix whose columns contain the traces\n    profilePos    along-profile coordinates of the traces\n    twtt          two-way travel time values for the samples, in ns",
        "detail": "csimGPR.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "linStackedAmplitude_alt2",
        "kind": 2,
        "importPath": "csimGPR.toolbox.gprpyTools",
        "description": "csimGPR.toolbox.gprpyTools",
        "peekOfCode": "def linStackedAmplitude_alt2(data,profilePos,twtt,vVals,tVals,typefact):\n    '''\n    Calculates the linear stacked amplitudes for each two-way \n    travel time sample and the provided velocity range \n    by summing the pixels of the data that follow a line given \n    by the two-way travel time zero offset and the velocity.\n    INPUT:\n    data          data matrix whose columns contain the traces\n    profilePos    along-profile coordinates of the traces\n    twtt          two-way travel time values for the samples, in ns",
        "detail": "csimGPR.toolbox.gprpyTools",
        "documentation": {}
    },
    {
        "label": "st",
        "kind": 2,
        "importPath": "csimGPR.toolbox.my_stran",
        "description": "csimGPR.toolbox.my_stran",
        "peekOfCode": "def st(data,minfreq=0,maxfreq=None,samprate=None,freqsamprate=1,remove_edge=False,analytic_signal=False,factor=1):\n    if data.shape[0] <= 1 or len(data.shape) > 1 :\n        raise TypeError('input data invalid ,please check!') \n    if not maxfreq and not samprate:\n        #regard signal as 1 second length\n        maxfreq=len(data)//2\n        samprate=len(data)\n    if maxfreq and not samprate:\n        samprate=len(data)\n    if not maxfreq and samprate:",
        "detail": "csimGPR.toolbox.my_stran",
        "documentation": {}
    },
    {
        "label": "ist",
        "kind": 2,
        "importPath": "csimGPR.toolbox.my_stran",
        "description": "csimGPR.toolbox.my_stran",
        "peekOfCode": "def ist(st_matrix):\n    # 1-D inverse stockwell transform code modified by GaoSong from origion ist.m code\n\t#    the input matrix must be redundant size(N,N//2+1)\n    stsp=np.sum(st_matrix,axis=1)\n    if st_matrix.shape[1] % 2 != 0:\n        negsp=stsp[2:].T[::-1]\n    else:\n        negsp=stsp[2:-1].T[::-1]\n    fullstsp=np.hstack((np.conjugate(stsp.T),negsp))\n    ts=np.fft.ifft(fullstsp).real",
        "detail": "csimGPR.toolbox.my_stran",
        "documentation": {}
    },
    {
        "label": "g_window",
        "kind": 2,
        "importPath": "csimGPR.toolbox.my_stran",
        "description": "csimGPR.toolbox.my_stran",
        "peekOfCode": "def g_window(length,freq,factor):    \n    # vector=np.zeros((2,length))\n    # for i in range(length):\n    #     vector[0,i]=i\n    #     vector[1,i]=-length+i\n    # vector=np.power(vector,2)\n    # vector=vector*(-factor*2*np.pi**2/freq**2)\n    # return sum(np.exp(vector))\n    gauss=signal.gaussian(length,std=(freq)/(2*np.pi*factor))\n    gauss=np.hstack((gauss,gauss))[length//2:length//2+length]",
        "detail": "csimGPR.toolbox.my_stran",
        "documentation": {}
    },
    {
        "label": "gprpyProfile",
        "kind": 6,
        "importPath": "csimGPR.csimGPR",
        "description": "csimGPR.csimGPR",
        "peekOfCode": "class gprpyProfile:\n    '''\n    Ground penetrating radar data processing and visualization class \n    for common-offset profiles.\n    '''\n    def __init__(self,filename=None):\n        '''\n        Initialization for a gprpyProfile object. Initialization can be \n        empty or with a provided filename for the GPR data.\n        INPUT:",
        "detail": "csimGPR.csimGPR",
        "documentation": {}
    },
    {
        "label": "GPRPyApp",
        "kind": 6,
        "importPath": "csimGPR.csimGPRGUI",
        "description": "csimGPR.csimGPRGUI",
        "peekOfCode": "class GPRPyApp:\n    '''\n    GPRPy class for graphical user interface for GPR profile data\n    '''\n    def __init__(self,master, colsp=2, rightcol=9, halfwid=6, figrowsp=21+1, figcolsp=9):\n        self.window = master\n        self.colsp = colsp\n        self.rightcol = rightcol\n        self.halfwid = halfwid\n        self.figrowsp = figrowsp",
        "detail": "csimGPR.csimGPRGUI",
        "documentation": {}
    },
    {
        "label": "interpSurface",
        "kind": 2,
        "importPath": "csimGPR.interpSurface",
        "description": "csimGPR.interpSurface",
        "peekOfCode": "def interpSurface(pointfile,outfile,nxgrid=100,nygrid=100,method='spline',delimiter='\\t',kx=1,ky=1):\n    '''\n    Creates a surface interpolating the provided three dimensional points.\n    INPUT:\n    pointfile      ASCII text file with three columns containing \n                   x, y, z or Easting, Northing, Elevation points               \n    outfile        filename for VTK file containing the surface \n                   interpolating the given points\n    nxgrid         number of mesh points along x-axis\n    nygrid         number of mesh points along y-axis",
        "detail": "csimGPR.interpSurface",
        "documentation": {}
    },
    {
        "label": "reduceSampling",
        "kind": 2,
        "importPath": "csimGPR.makeDataCube",
        "description": "csimGPR.makeDataCube",
        "peekOfCode": "def reduceSampling(gpr,nprofile,ntwtt):\n    '''\n    Helper function to coarsen the input data in order\n    to reduce memory and computational cost. This could \n    probably be replaced by scipy.ndimage.zoom\n    INPUT:\n    gpr          gprProfile object\n    nprofile     number of samples along the profile\n    ntwtt        number of samples along the travel time\n    '''",
        "detail": "csimGPR.makeDataCube",
        "documentation": {}
    },
    {
        "label": "makeDataCube",
        "kind": 2,
        "importPath": "csimGPR.makeDataCube",
        "description": "csimGPR.makeDataCube",
        "peekOfCode": "def makeDataCube(datalist,outname,nx=50,ny=50,nz=50,smooth=None,nprofile=None,ndepth=None,method='nearest',absvals=False):\n    '''\n    Creates an interpolated data cube from a list of .gpr (GPRPy)\n    preprocessed files. Allows for subsampling (to reduce computational \n    cost) and for smoothing (to help interpretation) \n    INPUT:\n    datalist      Python list containing the filenames (strings) for\n                  the preprocessed .gpr (GPRPy) data\n    outname       file name for the VTK file containing the resulting\n                  interpolated (and smoothed) data cube. Can be visualized ",
        "detail": "csimGPR.makeDataCube",
        "documentation": {}
    },
    {
        "label": "mergeProfiles",
        "kind": 2,
        "importPath": "csimGPR.mergeProfiles",
        "description": "csimGPR.mergeProfiles",
        "peekOfCode": "def mergeProfiles(file1,file2,outfile,gapfill=0):\n    '''\n    Merges two GPR profiles by placing the second one at the end \n    of the first one. \n    Make sure you preprocessed them in GPRPy and save them to have the \n    correct starting and end times for the profile, or to both start at\n    0 to just append the second profile at the end of the first profile.\n    INPUT: \n    file1      File name (including path) of the first profile\n    file2      File name (including path) of the second profile",
        "detail": "csimGPR.mergeProfiles",
        "documentation": {}
    },
    {
        "label": "#ScanNum",
        "kind": 5,
        "importPath": "test_LPR.Read_data_500MHz_002A",
        "description": "test_LPR.Read_data_500MHz_002A",
        "peekOfCode": "#ScanNum = 1063; #����\nScanNum = 8328\n#ScanNum = 3329; #����\nRecLen = 8283\nSampleNum = 2048\nRecOffset = 90\nLabNum = 4\nDatclonNum = ScanNum - 1\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190104004000_20190109213900_0001_A.2A','rb');\n#fin = fopen('/home/user/LPR/LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');",
        "detail": "test_LPR.Read_data_500MHz_002A",
        "documentation": {}
    },
    {
        "label": "ScanNum",
        "kind": 5,
        "importPath": "test_LPR.Read_data_500MHz_002A",
        "description": "test_LPR.Read_data_500MHz_002A",
        "peekOfCode": "ScanNum = 8328\n#ScanNum = 3329; #����\nRecLen = 8283\nSampleNum = 2048\nRecOffset = 90\nLabNum = 4\nDatclonNum = ScanNum - 1\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190104004000_20190109213900_0001_A.2A','rb');\n#fin = fopen('/home/user/LPR/LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');",
        "detail": "test_LPR.Read_data_500MHz_002A",
        "documentation": {}
    },
    {
        "label": "#ScanNum",
        "kind": 5,
        "importPath": "test_LPR.Read_data_500MHz_002A",
        "description": "test_LPR.Read_data_500MHz_002A",
        "peekOfCode": "#ScanNum = 3329; #����\nRecLen = 8283\nSampleNum = 2048\nRecOffset = 90\nLabNum = 4\nDatclonNum = ScanNum - 1\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190104004000_20190109213900_0001_A.2A','rb');\n#fin = fopen('/home/user/LPR/LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\npath = pwd",
        "detail": "test_LPR.Read_data_500MHz_002A",
        "documentation": {}
    },
    {
        "label": "RecLen",
        "kind": 5,
        "importPath": "test_LPR.Read_data_500MHz_002A",
        "description": "test_LPR.Read_data_500MHz_002A",
        "peekOfCode": "RecLen = 8283\nSampleNum = 2048\nRecOffset = 90\nLabNum = 4\nDatclonNum = ScanNum - 1\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190104004000_20190109213900_0001_A.2A','rb');\n#fin = fopen('/home/user/LPR/LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\npath = pwd\nfin = open(np.array([path,'/','LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A']),'rb')",
        "detail": "test_LPR.Read_data_500MHz_002A",
        "documentation": {}
    },
    {
        "label": "SampleNum",
        "kind": 5,
        "importPath": "test_LPR.Read_data_500MHz_002A",
        "description": "test_LPR.Read_data_500MHz_002A",
        "peekOfCode": "SampleNum = 2048\nRecOffset = 90\nLabNum = 4\nDatclonNum = ScanNum - 1\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190104004000_20190109213900_0001_A.2A','rb');\n#fin = fopen('/home/user/LPR/LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\npath = pwd\nfin = open(np.array([path,'/','LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A']),'rb')\nfout = open(np.array([path,'/','LPR_data/First/4 LPR/2A2.dat']),'wt')",
        "detail": "test_LPR.Read_data_500MHz_002A",
        "documentation": {}
    },
    {
        "label": "RecOffset",
        "kind": 5,
        "importPath": "test_LPR.Read_data_500MHz_002A",
        "description": "test_LPR.Read_data_500MHz_002A",
        "peekOfCode": "RecOffset = 90\nLabNum = 4\nDatclonNum = ScanNum - 1\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190104004000_20190109213900_0001_A.2A','rb');\n#fin = fopen('/home/user/LPR/LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\npath = pwd\nfin = open(np.array([path,'/','LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A']),'rb')\nfout = open(np.array([path,'/','LPR_data/First/4 LPR/2A2.dat']),'wt')\n# Data=zeros(SampleNum);",
        "detail": "test_LPR.Read_data_500MHz_002A",
        "documentation": {}
    },
    {
        "label": "LabNum",
        "kind": 5,
        "importPath": "test_LPR.Read_data_500MHz_002A",
        "description": "test_LPR.Read_data_500MHz_002A",
        "peekOfCode": "LabNum = 4\nDatclonNum = ScanNum - 1\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190104004000_20190109213900_0001_A.2A','rb');\n#fin = fopen('/home/user/LPR/LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\npath = pwd\nfin = open(np.array([path,'/','LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A']),'rb')\nfout = open(np.array([path,'/','LPR_data/First/4 LPR/2A2.dat']),'wt')\n# Data=zeros(SampleNum);\nfor i in np.arange(1,ScanNum - LabNum+1).reshape(-1):",
        "detail": "test_LPR.Read_data_500MHz_002A",
        "documentation": {}
    },
    {
        "label": "DatclonNum",
        "kind": 5,
        "importPath": "test_LPR.Read_data_500MHz_002A",
        "description": "test_LPR.Read_data_500MHz_002A",
        "peekOfCode": "DatclonNum = ScanNum - 1\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190104004000_20190109213900_0001_A.2A','rb');\n#fin = fopen('/home/user/LPR/LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\npath = pwd\nfin = open(np.array([path,'/','LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A']),'rb')\nfout = open(np.array([path,'/','LPR_data/First/4 LPR/2A2.dat']),'wt')\n# Data=zeros(SampleNum);\nfor i in np.arange(1,ScanNum - LabNum+1).reshape(-1):\n    fseek(fin,RecOffset + RecLen * (i + LabNum - 1),'bof')",
        "detail": "test_LPR.Read_data_500MHz_002A",
        "documentation": {}
    },
    {
        "label": "#fin",
        "kind": 5,
        "importPath": "test_LPR.Read_data_500MHz_002A",
        "description": "test_LPR.Read_data_500MHz_002A",
        "peekOfCode": "#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190104004000_20190109213900_0001_A.2A','rb');\n#fin = fopen('/home/user/LPR/LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\npath = pwd\nfin = open(np.array([path,'/','LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A']),'rb')\nfout = open(np.array([path,'/','LPR_data/First/4 LPR/2A2.dat']),'wt')\n# Data=zeros(SampleNum);\nfor i in np.arange(1,ScanNum - LabNum+1).reshape(-1):\n    fseek(fin,RecOffset + RecLen * (i + LabNum - 1),'bof')\n    A = fread(fin,SampleNum,'float32')",
        "detail": "test_LPR.Read_data_500MHz_002A",
        "documentation": {}
    },
    {
        "label": "#fin",
        "kind": 5,
        "importPath": "test_LPR.Read_data_500MHz_002A",
        "description": "test_LPR.Read_data_500MHz_002A",
        "peekOfCode": "#fin = fopen('/home/user/LPR/LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\n#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\npath = pwd\nfin = open(np.array([path,'/','LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A']),'rb')\nfout = open(np.array([path,'/','LPR_data/First/4 LPR/2A2.dat']),'wt')\n# Data=zeros(SampleNum);\nfor i in np.arange(1,ScanNum - LabNum+1).reshape(-1):\n    fseek(fin,RecOffset + RecLen * (i + LabNum - 1),'bof')\n    A = fread(fin,SampleNum,'float32')\n    for k in np.arange(1,SampleNum+1).reshape(-1):",
        "detail": "test_LPR.Read_data_500MHz_002A",
        "documentation": {}
    },
    {
        "label": "#fin",
        "kind": 5,
        "importPath": "test_LPR.Read_data_500MHz_002A",
        "description": "test_LPR.Read_data_500MHz_002A",
        "peekOfCode": "#fin = fopen('/home/user/LPR/2A/CE4_GRAS_LPR-2A_SCI_N_20190109213901_20190111150200_0002_A.2A','rb');\npath = pwd\nfin = open(np.array([path,'/','LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A']),'rb')\nfout = open(np.array([path,'/','LPR_data/First/4 LPR/2A2.dat']),'wt')\n# Data=zeros(SampleNum);\nfor i in np.arange(1,ScanNum - LabNum+1).reshape(-1):\n    fseek(fin,RecOffset + RecLen * (i + LabNum - 1),'bof')\n    A = fread(fin,SampleNum,'float32')\n    for k in np.arange(1,SampleNum+1).reshape(-1):\n        fout.write('%f ' % (A(k)))",
        "detail": "test_LPR.Read_data_500MHz_002A",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "test_LPR.Read_data_500MHz_002A",
        "description": "test_LPR.Read_data_500MHz_002A",
        "peekOfCode": "path = pwd\nfin = open(np.array([path,'/','LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A']),'rb')\nfout = open(np.array([path,'/','LPR_data/First/4 LPR/2A2.dat']),'wt')\n# Data=zeros(SampleNum);\nfor i in np.arange(1,ScanNum - LabNum+1).reshape(-1):\n    fseek(fin,RecOffset + RecLen * (i + LabNum - 1),'bof')\n    A = fread(fin,SampleNum,'float32')\n    for k in np.arange(1,SampleNum+1).reshape(-1):\n        fout.write('%f ' % (A(k)))\n        if rem(k,SampleNum) == 0:",
        "detail": "test_LPR.Read_data_500MHz_002A",
        "documentation": {}
    },
    {
        "label": "fin",
        "kind": 5,
        "importPath": "test_LPR.Read_data_500MHz_002A",
        "description": "test_LPR.Read_data_500MHz_002A",
        "peekOfCode": "fin = open(np.array([path,'/','LPR_data/First/4 LPR/2A/CE4_GRAS_LPR-1_SCI_N_20190109213901_20190111150200_0002_A.2A']),'rb')\nfout = open(np.array([path,'/','LPR_data/First/4 LPR/2A2.dat']),'wt')\n# Data=zeros(SampleNum);\nfor i in np.arange(1,ScanNum - LabNum+1).reshape(-1):\n    fseek(fin,RecOffset + RecLen * (i + LabNum - 1),'bof')\n    A = fread(fin,SampleNum,'float32')\n    for k in np.arange(1,SampleNum+1).reshape(-1):\n        fout.write('%f ' % (A(k)))\n        if rem(k,SampleNum) == 0:\n            fout.write('\\n' % ())",
        "detail": "test_LPR.Read_data_500MHz_002A",
        "documentation": {}
    },
    {
        "label": "fout",
        "kind": 5,
        "importPath": "test_LPR.Read_data_500MHz_002A",
        "description": "test_LPR.Read_data_500MHz_002A",
        "peekOfCode": "fout = open(np.array([path,'/','LPR_data/First/4 LPR/2A2.dat']),'wt')\n# Data=zeros(SampleNum);\nfor i in np.arange(1,ScanNum - LabNum+1).reshape(-1):\n    fseek(fin,RecOffset + RecLen * (i + LabNum - 1),'bof')\n    A = fread(fin,SampleNum,'float32')\n    for k in np.arange(1,SampleNum+1).reshape(-1):\n        fout.write('%f ' % (A(k)))\n        if rem(k,SampleNum) == 0:\n            fout.write('\\n' % ())\nfclose(fin)",
        "detail": "test_LPR.Read_data_500MHz_002A",
        "documentation": {}
    },
    {
        "label": "system",
        "kind": 5,
        "importPath": "RunPyinstaller",
        "description": "RunPyinstaller",
        "peekOfCode": "system = sys.platform\nprint(system)\nif system == 'darwin':\n    print('MacOS')\n    call(['pyinstaller', '-F', '-w', 'csimGPR/__main__.py', '-n', 'csimGPRapp', '-p', 'csimGPR/csimGPR.py',\n            '--add-data', 'csimGPR/startGUIdat/*:csimGPR/startGUIdat/',\n            '-i', 'csimGPR/startGUIdat/AnyConv.com__csimGPR_logo.icns',\n            '--hidden-import=Pmw', '--exclude-module=csimGPR/csimGPR/__main__.py'])\n            #'--add-data', '/Users/zhiyuzhang/miniconda3/lib/python3.10/site-packages/Pmw:Pmw'])\nelif system == 'linux':",
        "detail": "RunPyinstaller",
        "documentation": {}
    }
]